-- | Replay monad transformer
data ReplayT m q r a where
  Return  :: a -> ReplayT m q r a -- ^ Wraps an input in the `ReplayT` monad
  IoBind  :: (Monad m, Show a, Read a) => m a -> (a -> ReplayT m q r b) -> ReplayT m q r b
  AskBind :: q -> (r -> ReplayT m q r a) -> ReplayT m q r a
  CutBind :: (Monad m, Read a, Show a) => ReplayT m q r a -> (a -> ReplayT m q r b) -> ReplayT m q r b

-- | (ReplayT m q r a) is a monad
instance Monad (ReplayT m q r) where
  return = Return
  (>>=)  = bindT

-- | `bindT` implements the bind operator (>>=) for `ReplayT`
bindT :: ReplayT m q r a -> (a -> ReplayT m q r b) -> ReplayT m q r b
bindT (Return a) k = k a
bindT (IoBind a f) k = IoBind a (\x -> bindT (f x) k)
bindT (AskBind q f) k = AskBind q (\x -> bindT (f x) k)
bindT (CutBind w f) k = CutBind w (\x -> bindT (f x) k)

instance Applicative (ReplayT m q r) where
  pure  = return
  (<*>) = ap

instance Functor (ReplayT m q r) where
  fmap f x = pure f <*> x

-- | The `Trace` of a program is a list of actions that have been performed
type Trace r = [Item r]

-- | `Item` represents and action performed in a program
data Item r = Answer r | Result String | ShortCut String | Filler
  deriving (Show, Read)

{- $function -}

-- | Lift a monad to ReplayT
liftR :: (Monad m, Show a, Read a) => m a -> ReplayT m q r a
liftR = ioT

-- | Performs a monadic action, the result is ignored if there already an result
-- in the input trace
ioT :: (Monad m, Show a, Read a) => m a -> ReplayT m q r a
ioT a = IoBind a Return

-- | Stops the whole program to ask the user a question.
askT :: q -> ReplayT m q r r
askT q = AskBind q Return

-- | Produces a shortcut to prevent calculating already known values
cutT :: (Monad m, Read a, Show a) => ReplayT m q r a -> ReplayT m q r a
cutT w = CutBind w Return

-- | `emptyTrace` returns an empty trace
emptyTrace :: Trace r
emptyTrace = []

-- | `addAnswer` adds an answer to a given trace
addAnswer :: Trace r -> r -> Trace r
addAnswer t r = t ++ [Answer r]

-- | `runT` runs a ReplayT program wrapped by a given monad `m`
runT :: (Monad m) => ReplayT m q r a -> Trace r -> m (Either (q, Trace r) a)
runT (Return a) r                  = return (Right a)
runT (IoBind a f) (Result s:ss)    = runH (runT (f (read s)) ss) (Result s)
runT (IoBind a f) []               = do e <- a
                                        runH (runT (f e) []) (Result (show e))
runT (AskBind q f) (Answer r:rs)   = runH (runT (f r) rs) (Answer r) 
runT (AskBind q f) t               = return (Left (q, t))
runT (CutBind w f) (ShortCut s:ss) = runH (runT (f (read s)) ss) (ShortCut s)
runT (CutBind w f) t = case t of
  (Filler:ss) -> runShortCut ss
  _           -> runShortCut t
  where
    runShortCut t =  
              do val <- runT w t
                 case val of
                   Left (q,t2) -> return (Left (q, Filler:t2))
                   Right a2    -> runH (runT (f a2) []) (ShortCut (show a2))



-- | Helper function to `runT`, exists to avoid repetitive code
runH :: (Monad m) => m (Either (q, Trace r) a) -> Item r -> m (Either (q, Trace r) a)
runH m r = do val <- m
              case val of
                  Left(q,t) -> return (Left (q,r:t))
                  Right a2 -> return (Right a2)


-------------------------------------------------------------------------------------------
Edvins version:
-------------------------------------------------------------------------------------------

-- | Item type for already computed things in the trace.
data Item r = Answer r | Result String
  deriving (Show,Read)
-- | The trace with already computed things.
type Trace r = [Item r]
-- | The state within the replay monad. 
--   Contains two traces, one for unused and one for used answers/results.
type ReplayState r = (Trace r, Trace r)

-- | Replay monad transformer. Contains a state and except monad transformer.
newtype ReplayT q r m a = 
  ReplayT (StateT (ReplayState r) (ExceptT (q, Trace r) m) a)
    deriving (Functor, Applicative, Monad,
              MonadState (ReplayState r),
              MonadError (q, Trace r))

-- | Replay monad. Made with the replay monad 
--   transformer applied on the IO monad.
type Replay q r a = ReplayT q r IO a

-- | liftR is the lift method for the replay monad transformer.
--   If the computation is already done it returns the old result.
--   Otherwise it lifts the action to the top monad.
liftR :: (Monad m, Show a, Read a) => m a -> ReplayT q r m a
liftR m = ReplayT $ do
  (leftT,rightT) <- get
  case leftT of
    (Result a):rest -> put (rest, rightT ++ [Result a]) >> return (read a)
    _               -> do
      a <- lift . lift $ m
      put (leftT, rightT ++ [Result (show a)])
      return a

-- | io is a method for the replay monad to perform actions
--   within the IO monad.
io :: (Show a, Read a) => IO a -> Replay q r a
io = liftR

-- | ask gets a question and looks in the trace to see if
--   it has been answered. If not it pauses the program and
--   asks the question.
ask :: q -> Replay q r r
ask question = do
  (leftT, rightT) <- get
  if null leftT then
      throwError (question, rightT)
  else do
      case head leftT of
        (Answer r) -> put (tail leftT, rightT ++ [head leftT]) >> return r
        _          -> error "Received unexpected item in trace"

-- | An empty trace
emptyTrace :: Trace r
emptyTrace = []

-- | Add an answer to the trace
addAnswer :: Trace r -> r -> Trace r
addAnswer t r = t ++ [Answer r]

-- | The run function. It gets a program and a trace with everything
--   already computed.
run :: Monad m => ReplayT q r m a -> Trace r -> m (Either (q, Trace r) a)
run (ReplayT prog) trace = runExceptT (evalStateT prog (trace,[]))

